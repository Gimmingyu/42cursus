#PUSH SWAP

## General Instructions

- LIBFT 사용가능
- Makefile 이용해서 컴파일.
- Norminette기반한 C로 작성.
- 실행 파일의 이름은 push_swap.c로 할 것.
- 허용함수: write, read, malloc, free, exit
- Memory leak에 주의하고, 예외 및 에러처리에 주의해서 프로그램을 작성할 것.

---

## Game rules

A와 B 스택이 있다고 가정하자.

A는 서로 중복되지 않는 음수 혹은 양수인 난수들을 포함하며, B는 비어있다.

목표는 스택 A에 오름차순으로 수를 정렬하는 것인데, 이를 위해 다음 연산들을 수행할 수 있다.

> sa: swap a  
> 스택 A의 가장 위에 있는 두 원소의 위치를 서로 바꾼다.

> sb: swap b  
> 스택 B의 가장 위에 있는 두 원소의 위치를 서로 바꾼다.

> ss: sa and sb  
> sa와 sb를 동시에 실행

> pa: push a  
> 스택 B에서 가장 위에 있는 원소를 스택 A의 맨 위에 넣는다. 스택 B가 비어있으면 아무 동작도 하지 않는다.

> pb: push b  
> 스택 A에서 가장 위에 있는 원소를 스택 B의 맨 위에 넣는다. 스택 A가 비어있으면 아무 동작도 하지 않는다.

> ra: rotate a  
> 스택 A의 모든 원소들을 위로 1칸씩 올린다. 맨 위가 맨 아래 원소가 된다.

> rb: rotate b  
> 스택 B의 모든 원소들을 위로 1칸씩 올린다. 맨 위가 맨 아래 원소가 된다.

> rr: ra and rb  
> ra와 rb를 동시에 실행한다.

> rra: reverse rotate a  
> 스택 A의 모든 원소들을 아래로 1칸씩 내린다. 맨 아래가 맨 위 원소가 된다.

> rrb: reverse rotate b  
> 스택 B의 모든 원소들을 아래로 1칸씩 내린다. 맨 아래가 맨 위 원소가 된다.

> rrr: rra and rrb  
> rra와 rrb를 동시에 실행한다.

---

push_swap 프로그램은 스택 A에 들어갈 값들을 정수 리스트의 형태로 포매팅하여 인자로 받는다. (첫 번째 인자가 Top)

스택 A를 정렬하는데 가능한 가장 작은 개수의 명령어 리스트를 출력한다.

명령어들은 new_line으로 구분된다.

가능한 적은 개수의 명령어 집합으로 스택을 정렬하는 것이 목표이고,

평가 도중에는 프로그램에서 도출한 명령어의 수와 허용된 최대 작업수를 비교한다.

너무 큰 리스트가 출력되거나 목록이 제대로 정렬되지 않은 경우 감점.

에러의 경우 Error와 줄바꿈을 표준 에러로 출력.

@FIXME: ft_atoi를 custom... atoi에서 잘못된 값인 경우 stack을 지우면서 에러 출력해야한다. 현재는 leak 발생 예상.
